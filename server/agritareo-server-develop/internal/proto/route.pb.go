// Code generated by protoc-gen-go. DO NOT EDIT.
// source: internal/proto/route.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() {
	proto.RegisterFile("internal/proto/route.proto", fileDescriptor_fc49ff62c4a9744c)
}

var fileDescriptor_fc49ff62c4a9744c = []byte{
	// 257 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x91, 0xcd, 0x4a, 0x03, 0x31,
	0x14, 0x46, 0x19, 0xa1, 0x5a, 0xae, 0xd6, 0x45, 0xf0, 0x07, 0xa3, 0x6e, 0x5c, 0xb9, 0xb1, 0x2d,
	0x8a, 0x9b, 0x16, 0x04, 0x17, 0x22, 0x2e, 0x74, 0x31, 0xe2, 0x03, 0x44, 0xbd, 0x4e, 0x03, 0x36,
	0x89, 0xc9, 0x0d, 0xe8, 0x5b, 0xfb, 0x08, 0x62, 0x72, 0xd3, 0xd2, 0xb8, 0x72, 0x35, 0xc3, 0x39,
	0xdf, 0x81, 0x4c, 0x06, 0xa4, 0x36, 0x84, 0xde, 0xa8, 0xf7, 0x91, 0xf3, 0x96, 0xec, 0xc8, 0xdb,
	0x48, 0x38, 0x4c, 0xef, 0xa2, 0x97, 0x1e, 0xf2, 0xb8, 0x9a, 0xcc, 0x31, 0x04, 0xd5, 0x61, 0xc8,
	0x2b, 0x79, 0x54, 0xe9, 0xe8, 0x5e, 0x15, 0xa1, 0x67, 0x7b, 0x58, 0x59, 0x63, 0x49, 0xbf, 0x7d,
	0xb1, 0x3c, 0xa8, 0xa4, 0x8a, 0x34, 0x63, 0x75, 0x52, 0x29, 0xfc, 0x7c, 0x99, 0x29, 0xd3, 0xe1,
	0x99, 0x57, 0xe5, 0x7c, 0xe7, 0xdf, 0x6b, 0xd0, 0x6b, 0x7f, 0xcf, 0x2b, 0xa6, 0xd0, 0x6f, 0xb1,
	0xd3, 0x81, 0xd0, 0x8b, 0xbd, 0x6c, 0x87, 0x05, 0xb4, 0xf8, 0x11, 0x31, 0x90, 0xdc, 0xff, 0xc3,
	0x83, 0xb3, 0x26, 0xa0, 0x98, 0xc0, 0xc6, 0x9d, 0xd1, 0x74, 0xed, 0xdc, 0xff, 0xdb, 0x2b, 0xd8,
	0xbc, 0x45, 0xba, 0xe7, 0x1b, 0x59, 0xf4, 0x05, 0xd4, 0xfd, 0x92, 0x73, 0x3f, 0x85, 0xfe, 0x0d,
	0x7f, 0xd9, 0x22, 0x2e, 0xa0, 0x8e, 0x97, 0x9c, 0xe3, 0x4b, 0xd8, 0x7a, 0x48, 0xd7, 0xf9, 0x48,
	0x1e, 0xd5, 0x5c, 0xec, 0xf0, 0x30, 0xc3, 0x92, 0x0f, 0x56, 0xe8, 0xb8, 0x11, 0x13, 0x18, 0x3c,
	0xe5, 0x7f, 0xc4, 0xdd, 0x2e, 0x2f, 0x98, 0x96, 0x70, 0x7b, 0x15, 0x9f, 0x36, 0xe3, 0xe6, 0x79,
	0x3d, 0xa1, 0x8b, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb2, 0x41, 0x92, 0x9d, 0x37, 0x02, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// RouteClient is the client API for Route service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RouteClient interface {
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	// deprecated
	InitApp(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	GetMessages(ctx context.Context, in *MessagesRequest, opts ...grpc.CallOption) (*MessagesResponse, error)
	Exchange(ctx context.Context, in *ExchangeRequest, opts ...grpc.CallOption) (*ExchangeResponse, error)
	NotifyStream(ctx context.Context, in *NotifyRequest, opts ...grpc.CallOption) (Route_NotifyStreamClient, error)
	UpdaterStream(ctx context.Context, opts ...grpc.CallOption) (Route_UpdaterStreamClient, error)
}

type routeClient struct {
	cc grpc.ClientConnInterface
}

func NewRouteClient(cc grpc.ClientConnInterface) RouteClient {
	return &routeClient{cc}
}

func (c *routeClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, "/proto.Route/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) InitApp(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, "/proto.Route/InitApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) GetMessages(ctx context.Context, in *MessagesRequest, opts ...grpc.CallOption) (*MessagesResponse, error) {
	out := new(MessagesResponse)
	err := c.cc.Invoke(ctx, "/proto.Route/GetMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) Exchange(ctx context.Context, in *ExchangeRequest, opts ...grpc.CallOption) (*ExchangeResponse, error) {
	out := new(ExchangeResponse)
	err := c.cc.Invoke(ctx, "/proto.Route/Exchange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeClient) NotifyStream(ctx context.Context, in *NotifyRequest, opts ...grpc.CallOption) (Route_NotifyStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Route_serviceDesc.Streams[0], "/proto.Route/NotifyStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeNotifyStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Route_NotifyStreamClient interface {
	Recv() (*Notify, error)
	grpc.ClientStream
}

type routeNotifyStreamClient struct {
	grpc.ClientStream
}

func (x *routeNotifyStreamClient) Recv() (*Notify, error) {
	m := new(Notify)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routeClient) UpdaterStream(ctx context.Context, opts ...grpc.CallOption) (Route_UpdaterStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Route_serviceDesc.Streams[1], "/proto.Route/UpdaterStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &routeUpdaterStreamClient{stream}
	return x, nil
}

type Route_UpdaterStreamClient interface {
	Send(*UpdaterRequest) error
	Recv() (*Updater, error)
	grpc.ClientStream
}

type routeUpdaterStreamClient struct {
	grpc.ClientStream
}

func (x *routeUpdaterStreamClient) Send(m *UpdaterRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routeUpdaterStreamClient) Recv() (*Updater, error) {
	m := new(Updater)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RouteServer is the server API for Route service.
type RouteServer interface {
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	// deprecated
	InitApp(context.Context, *RegisterRequest) (*RegisterResponse, error)
	GetMessages(context.Context, *MessagesRequest) (*MessagesResponse, error)
	Exchange(context.Context, *ExchangeRequest) (*ExchangeResponse, error)
	NotifyStream(*NotifyRequest, Route_NotifyStreamServer) error
	UpdaterStream(Route_UpdaterStreamServer) error
}

// UnimplementedRouteServer can be embedded to have forward compatible implementations.
type UnimplementedRouteServer struct {
}

func (*UnimplementedRouteServer) Register(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (*UnimplementedRouteServer) InitApp(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitApp not implemented")
}
func (*UnimplementedRouteServer) GetMessages(ctx context.Context, req *MessagesRequest) (*MessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMessages not implemented")
}
func (*UnimplementedRouteServer) Exchange(ctx context.Context, req *ExchangeRequest) (*ExchangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exchange not implemented")
}
func (*UnimplementedRouteServer) NotifyStream(req *NotifyRequest, srv Route_NotifyStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method NotifyStream not implemented")
}
func (*UnimplementedRouteServer) UpdaterStream(srv Route_UpdaterStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdaterStream not implemented")
}

func RegisterRouteServer(s *grpc.Server, srv RouteServer) {
	s.RegisterService(&_Route_serviceDesc, srv)
}

func _Route_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Route/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_InitApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).InitApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Route/InitApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).InitApp(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_GetMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).GetMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Route/GetMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).GetMessages(ctx, req.(*MessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_Exchange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExchangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteServer).Exchange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Route/Exchange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteServer).Exchange(ctx, req.(*ExchangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Route_NotifyStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NotifyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouteServer).NotifyStream(m, &routeNotifyStreamServer{stream})
}

type Route_NotifyStreamServer interface {
	Send(*Notify) error
	grpc.ServerStream
}

type routeNotifyStreamServer struct {
	grpc.ServerStream
}

func (x *routeNotifyStreamServer) Send(m *Notify) error {
	return x.ServerStream.SendMsg(m)
}

func _Route_UpdaterStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouteServer).UpdaterStream(&routeUpdaterStreamServer{stream})
}

type Route_UpdaterStreamServer interface {
	Send(*Updater) error
	Recv() (*UpdaterRequest, error)
	grpc.ServerStream
}

type routeUpdaterStreamServer struct {
	grpc.ServerStream
}

func (x *routeUpdaterStreamServer) Send(m *Updater) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routeUpdaterStreamServer) Recv() (*UpdaterRequest, error) {
	m := new(UpdaterRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Route_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Route",
	HandlerType: (*RouteServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Route_Register_Handler,
		},
		{
			MethodName: "InitApp",
			Handler:    _Route_InitApp_Handler,
		},
		{
			MethodName: "GetMessages",
			Handler:    _Route_GetMessages_Handler,
		},
		{
			MethodName: "Exchange",
			Handler:    _Route_Exchange_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "NotifyStream",
			Handler:       _Route_NotifyStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UpdaterStream",
			Handler:       _Route_UpdaterStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "internal/proto/route.proto",
}
